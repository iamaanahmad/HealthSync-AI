About Artificial Superintelligence Alliance
The Artificial Superintelligence (ASI) Alliance unites Fetch.ai, SingularityNET, Ocean Protocol, and CUDOS to build a decentralized, ethical, and accessible AI ecosystem. Together, we’re pioneering the future of artificial intelligence and Web3 innovation.

Challenge Statement
Build Autonomous AI Agents with the ASI Alliance

This is your opportunity to develop AI agents that don't just execute code—they perceive, reason, and act across decentralized systems. The ASI Alliance in partnership with Fetch.ai Innovation Lab, brings together world-class infrastructure from Fetch.ai and SingularityNET to support the next generation of modular, autonomous AI systems.

Use Fetch.ai's uAgents framework or your preferred agentic stack to build agents that can interpret natural language, make decisions, and trigger real-world actions. Deploy them to Agentverse, the ASI-wide registry and orchestration layer where agents connect, collaborate, and self-organize.

Enhance your agents with structured knowledge from SingularityNET's MeTTa Knowledge Graph. For agent discovery and human interaction, integrate the Chat Protocol to make your agents accessible through the ASI:One interface.

Whether you're building in healthcare, logistics, finance, education, or DeAI-native applications—this is your launchpad. Develop agents that talk to each other. That learn and adapt. That drive real outcomes across sectors.

The future of decentralized AI isn't siloed. It's composable, cross-chain, and powered by the ASI Alliance.

Resources
Fetch.ai Resources
How to create an Agent with uAgents Framework ↗

Communication between two uAgents ↗

How to create ASI:One compatible uAgents ↗

Innovation Lab GitHub Repo ↗

Past Hackathon Projects ↗

How to write a good Readme for your Agents ↗

Singularity.net Resources
Understanding MeTTa ↗

Running MeTTa in Python ↗

Nested queries and recursive graph traversal ↗

Setup MeTTa on Window OS ↗

Fetch.ai and MeTTa Integration ↗

Submission Requirements
Code

Share the link to your public GitHub repository to allow judges to access and test your project.

Ensure your README.md file includes key details about your agents, such as their name and address, for easy reference.

Mention any extra resources required to run your project and provide links to those resources.

All agents must be categorized under Innovation Lab.

To achieve this, include the following badge in your agent’s README.md file:


![tag:innovationlab](https://img.shields.io/badge/innovationlab-3D8BD3)
![tag:hackathon](https://img.shields.io/badge/hackathon-5F43F1)
Video

Include a demo video (3–5 minutes) demonstrating the agents you have built.

Judging Criteria
Functionality & Technical Implementation (25%)

Does the agent system work as intended?

Are the agents properly communicating and reasoning in real time?

Use of ASI Alliance Tech (20%)

Are agents registered on Agentverse?

Is the Chat Protocol live for ASI:One?

Does your solution make use of uAgents and MeTTa Knowledge Graphs tools?

Innovation & Creativity (20%)

How original or creative is the solution?

Is it solving a problem in a new or unconventional way?

Real-World Impact & Usefulness (20%)

Does the solution solve a meaningful problem?

How useful would this be to an end user?

User Experience & Presentation (15%)

Is the demo clear and well-structured?

Is the user experience smooth and easy to follow?

The solution should include comprehensive documentation, detailing the use and integration of each technology involved.

Prize Terms and Conditions
Prizes will be awarded based on project quality and only to teams that meaningfully use Fetch.ai and SingularityNET technologies.

All agents must be registered on Agentverse with the Chat Protocol enabled to be discoverable through ASI:One.

Agentverse MCP Server
Learn how to deploy your first agent on Agentverse with Claude Desktop in Under 5 Minutes

Agentverse MCP Setup

Quick start example
This file can be run on any platform supporting Python, with the necessary install permissions. This example shows two agents communicating with each other using the uAgent python library.
Try it out on Agentverse ↗

from datetime import datetime
from uuid import uuid4
from uagents.setup import fund_agent_if_low
from uagents_core.contrib.protocols.chat import (
   ChatAcknowledgement,
   ChatMessage,
   EndSessionContent,
   StartSessionContent,
   TextContent,
   chat_protocol_spec,
)


agent = Agent()


# Initialize the chat protocol with the standard chat spec
chat_proto = Protocol(spec=chat_protocol_spec)


# Utility function to wrap plain text into a ChatMessage
def create_text_chat(text: str, end_session: bool = False) -> ChatMessage:
content = [TextContent(type="text", text=text)]
   return ChatMessage(
       timestamp=datetime.utcnow(),
       msg_id=uuid4(),
       content=content,
   )


# Handle incoming chat messages
@chat_proto.on_message(ChatMessage)
async def handle_message(ctx: Context, sender: str, msg: ChatMessage):
   ctx.logger.info(f"Received message from {sender}")
  
   # Always send back an acknowledgement when a message is received
   await ctx.send(sender, ChatAcknowledgement(timestamp=datetime.utcnow(), acknowledged_msg_id=msg.msg_id))


   # Process each content item inside the chat message
   for item in msg.content:
       # Marks the start of a chat session
       if isinstance(item, StartSessionContent):
           ctx.logger.info(f"Session started with {sender}")
      
       # Handles plain text messages (from another agent or ASI:One)
       elif isinstance(item, TextContent):
           ctx.logger.info(f"Text message from {sender}: {item.text}")
           #Add your logic
           # Example: respond with a message describing the result of a completed task
           response_message = create_text_chat("Hello from Agent")
           await ctx.send(sender, response_message)


       # Marks the end of a chat session
       elif isinstance(item, EndSessionContent):
           ctx.logger.info(f"Session ended with {sender}")
       # Catches anything unexpected
       else:
           ctx.logger.info(f"Received unexpected content type from {sender}")


# Handle acknowledgements for messages this agent has sent out
@chat_proto.on_message(ChatAcknowledgement)
async def handle_acknowledgement(ctx: Context, sender: str, msg: ChatAcknowledgement):
   ctx.logger.info(f"Received acknowledgement from {sender} for message {msg.acknowledged_msg_id}")


# Include the chat protocol and publish the manifest to Agentverse
agent.include(chat_proto, publish_manifest=True)


if __name__ == "__main__": 
    agent.run()
